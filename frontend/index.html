<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java Vulnerability Scanner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        /* Custom CSS for a modern, animated, and clean UI */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* A lighter, cleaner gray (slate-50) */
            color: #334155; /* slate-700 */
        }

        .container {
            max-width: 90%; /* Utilize more screen width for better code viewing */
            margin: 3rem auto;
            padding: 3rem;
            background-color: #ffffff;
            border-radius: 1.5rem; /* Softer, larger radius */
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.1); /* Softer, more diffuse shadow */
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        h1 {
            color: #1e293b; /* slate-900 */
        }
        
        h2 {
           color: #334155; /* slate-700 */
        }

        h3 {
           color: #475569; /* slate-600 */
        }

        /* Enhanced File Upload Box */
        .file-upload-container {
            border: 2px dashed #cbd5e1; /* slate-300 */
            background-color: #f8fafc; /* slate-50 */
            border-radius: 1.25rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
        }

        .file-upload-container:hover {
            background-color: #f0f9ff; /* sky-50 on hover */
            border-color: #7dd3fc; /* sky-300 on hover */
            transform: translateY(-4px);
            box-shadow: 0 10px 15px -3px rgba(56, 189, 248, 0.1), 0 4px 6px -2px rgba(56, 189, 248, 0.07);
        }
        
        /* Base button styles for consistency and modern feel */
        .button {
             padding: 0.875rem 2.5rem; /* 14px 40px */
             border-radius: 9999px; /* pill shape */
             font-weight: 600;
             letter-spacing: 0.025em;
             outline: none;
             transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
             transform-origin: center;
        }
        
        .button:hover {
             transform: scale(1.03);
             box-shadow: 0 10px 20px -5px rgba(0,0,0,0.1);
        }

        .button:active {
            transform: scale(0.98);
        }

        .button:focus-visible {
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.4);
        }

        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: scale(1);
            box-shadow: none;
        }

        /* Table styles for a cleaner, more modern look */
        .table-container {
            border-radius: 1rem;
            overflow: hidden;
            border: 1px solid #e2e8f0; /* slate-200 */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
        }

        th {
            background-color: #f8fafc; /* slate-50 */
            text-transform: uppercase;
            font-size: 0.75rem; /* 12px */
            font-weight: 600;
            color: #64748b; /* slate-500 */
            letter-spacing: 0.05em;
        }

        tbody tr:hover {
            background-color: #f8fafc; /* slate-50 */
            transition: background-color 0.2s ease-in-out;
        }

        /* Code Block and Line Numbering Styles */
        pre {
            background-color: #1e293b; /* slate-800 */
            color: #e2e8f0; /* slate-200 */
            padding: 1.5rem;
            border-radius: 0.75rem;
            overflow-x: auto;
            font-size: 0.875rem; /* 14px */
            line-height: 1.7; /* Increased for readability */
        }
        
        .line-numbers-container {
            position: relative;
            padding-left: 4rem; 
            counter-reset: line-number;
        }

        .line-numbers-container .line {
            display: block;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .line-numbers-container .line::before {
            content: counter(line-number);
            counter-increment: line-number;
            position: absolute;
            left: 0;
            width: 3rem;
            text-align: right;
            color: #64748b; /* slate-500 */
            font-size: 0.8rem;
            user-select: none;
            padding-right: 1rem;
        }
        
        /* Message Box and Notification Styles */
        .message-box {
            padding: 1rem 1.5rem;
            border-radius: 0.75rem;
            margin-bottom: 1.5rem;
            font-weight: 500;
            border-width: 1px;
            opacity: 0;
            transition: opacity 0.4s ease, transform 0.4s ease;
            transform: translateY(10px);
        }
        .message-box.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        #transient-notification {
            position: fixed;
            top: 1.5rem;
            right: 1.5rem;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            opacity: 0;
            transform: translateY(-20px) scale(0.95);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            font-weight: 500;
        }
        #transient-notification.show {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        /* Loading Spinner */
        .loading-spinner {
            border: 4px solid #e2e8f0; /* slate-200 */
            border-top: 4px solid #3b82f6; /* blue-500 */
            border-radius: 50%;
            width: 48px;
            height: 48px;
            animation: spin 1s linear infinite;
            margin: 2rem auto;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .loading-spinner.show {
            opacity: 1;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* General animated reveal for sections */
        .revealable {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        .revealable.show {
            opacity: 1;
            transform: translateY(0);
        }

        /* Tab styling */
        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 2rem;
            background-color: #e2e8f0;
            border-radius: 0.75rem;
            padding: 0.5rem;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        .tab-button {
            flex: 1;
            padding: 1rem 1.5rem;
            font-weight: 600;
            color: #475569;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        .tab-button.active {
            background-color: #ffffff;
            color: #3b82f6;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .tab-button:hover:not(.active) {
            background-color: #f0f4f8;
        }
        .tab-content {
            display: none;
            padding: 1rem;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            margin-top: 1rem;
            background-color: #ffffff;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1);
        }
        .tab-content.active {
            display: block;
        }
        /* Style for hidden elements to prevent CLS */
        .hidden-visually {
            display: none;
            visibility: hidden;
            height: 0;
            overflow: hidden;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" defer></script>
</head>
<body class="bg-slate-50">
    <div class="container">
        <div class="text-center mb-12">
            <h1 class="text-5xl font-extrabold mb-4">üîê SSL/HTTPS Vulnerability Scanner</h1>
            <p class="text-lg text-slate-600 max-w-2xl mx-auto">
                Analyze your Java code for insecure usage of <strong>X509TrustManager</strong>,
                <strong>HostnameVerifier</strong>, weak <strong>cipher suites</strong>, and more. Get suggestions and <strong>auto-patch</strong> options.
            </p>
        </div>

        <div class="tabs">
            <button class="tab-button active" data-tab="upload-file">üì§ Upload .java File</button>
            <button class="tab-button" data-tab="paste-code">üìù Paste Java Code</button>
            <button class="tab-button" data-tab="upload-zip">üóÇÔ∏è Upload ZIP Archive</button>
        </div>

        <div id="upload-file-tab-content" class="tab-content active">
            <h2 class="text-3xl font-bold mb-6 text-slate-700">üìÇ Upload a Single Java File</h2>
            <div class="file-upload-container mb-10 text-center relative" id="single-file-drop-area">
                <input type="file" id="single-file-upload" accept=".java" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer">
                <div class="flex flex-col items-center justify-center p-8 pointer-events-none">
                    <svg class="w-16 h-16 text-sky-500 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                    </svg>
                    <p class="text-lg font-semibold text-slate-700 mb-2">Drag & Drop or Click to Upload</p>
                    <span id="single-file-name" class="block text-slate-500 text-sm">No file chosen</span>
                </div>
            </div>
            <div class="text-center">
                <button id="scan-single-file-button" class="button bg-blue-600 text-white hover:bg-blue-700">
                    Scan for Vulnerabilities
                </button>
            </div>
        </div>

        <div id="paste-code-tab-content" class="tab-content">
            <h2 class="text-3xl font-bold mb-6 text-slate-700">‚úçÔ∏è Paste Java Code</h2>
            <textarea id="pasted-code-textarea" class="w-full p-4 border border-slate-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-200" rows="15" placeholder="public class MyClass {&#10;    // ... your Java code ...&#10;}"></textarea>
            <div class="text-center mt-6">
                <button id="scan-pasted-code-button" class="button bg-blue-600 text-white hover:bg-blue-700">
                    Scan Pasted Code
                </button>
            </div>
        </div>

        <div id="upload-zip-tab-content" class="tab-content">
            <h2 class="text-3xl font-bold mb-6 text-slate-700">üóÇÔ∏è Upload ZIP Archive</h2>
            <div class="file-upload-container mb-10 text-center relative" id="zip-file-drop-area">
                <input type="file" id="zip-file-upload" accept=".zip" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer">
                <div class="flex flex-col items-center justify-center p-8 pointer-events-none">
                    <svg class="w-16 h-16 text-sky-500 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5"></path>
                    </svg>
                    <p class="text-lg font-semibold text-slate-700 mb-2">Drag & Drop or Click to Upload ZIP</p>
                    <span id="zip-file-name" class="block text-slate-500 text-sm">No ZIP file chosen</span>
                </div>
            </div>
            <div class="text-center">
                <button id="process-zip-button" class="button bg-blue-600 text-white hover:bg-blue-700">
                    Process ZIP Archive
                </button>
            </div>
            <div id="zip-results-container" class="mt-8"></div>
        </div>


        <div id="loading-analysis" class="loading-spinner"></div>
        <div id="analysis-message" class="message-box mt-8"></div>

        <div id="analysis-results" class="revealable mt-12 hidden-visually">
            <h2 class="text-3xl font-bold mb-6 text-slate-700">Analysis Results</h2>
            <div class="table-container">
                <table class="min-w-full">
                    <thead>
                        <tr>
                            <th class="px-6 py-4">Line</th>
                            <th class="px-6 py-4">Severity</th>
                            <th class="px-6 py-4">Issue</th>
                            <th class="px-6 py-4">Suggestion</th>
                            <th class="px-6 py-4">Code Snippet</th>
                        </tr>
                    </thead>
                    <tbody id="results-table-body" class="bg-white divide-y divide-slate-200">
                        </tbody>
                </table>
            </div>
            <div id="no-vulnerabilities-message" class="message-box success mt-6 border-green-300 bg-green-50 text-green-800 hidden">
                ‚úÖ No SSL/HTTPS vulnerabilities found. Your code looks secure!
            </div>
        </div>

        <div id="auto-patch-section" class="revealable mt-16 text-center hidden-visually">
            <h2 class="text-3xl font-bold mb-5 text-slate-700">Auto-Patch Code</h2>
            <button id="patch-button" class="button bg-emerald-600 text-white hover:bg-emerald-700">
                Generate Patched Code
            </button>

            <div id="loading-patch" class="loading-spinner"></div>
            <div id="patch-message" class="message-box mt-6"></div>

            <div id="patched-code-display" class="revealable mt-8 text-left hidden-visually">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-2xl font-bold text-slate-600">Patched Java Code:</h3>
                    <button class="button text-sm py-2 px-4 bg-slate-700 text-white hover:bg-slate-800" onclick="copyToClipboard('patched-code-pre')">Copy Code</button>
                </div>
                <pre id="patched-code-pre" class="mt-2 line-numbers-container"></pre>
                
                <div id="patch-log-details" class="revealable mt-8 hidden-visually">
                    <h4 class="font-semibold text-xl mb-3 text-sky-800">Patch Log Details:</h4>
                    <pre id="patch-log-pre" class="bg-sky-50 text-sky-900 border border-sky-200"></pre>
                    <div class="text-sm mt-3 text-sky-700">The patch log shows all changes (line numbers and descriptions) applied by the Auto-Patcher.</div>
                </div>
            </div>
        </div>
    </div>

    <div id="transient-notification"></div>

    <script>
        // DOM Element References
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        // For single file upload
        const singleFileInput = document.getElementById('single-file-upload');
        const singleFileNameSpan = document.getElementById('single-file-name');
        const scanSingleFileButton = document.getElementById('scan-single-file-button');
        const singleFileDropArea = document.getElementById('single-file-drop-area');

        // For paste code
        const pastedCodeTextarea = document.getElementById('pasted-code-textarea');
        const scanPastedCodeButton = document.getElementById('scan-pasted-code-button');

        // For ZIP file upload
        const zipFileInput = document.getElementById('zip-file-upload');
        const zipFileNameSpan = document.getElementById('zip-file-name');
        const processZipButton = document.getElementById('process-zip-button');
        const zipFileDropArea = document.getElementById('zip-file-drop-area');
        const zipResultsContainer = document.getElementById('zip-results-container');

        // Universal elements for results and feedback
        const loadingAnalysis = document.getElementById('loading-analysis');
        const loadingPatch = document.getElementById('loading-patch');
        const analysisMessage = document.getElementById('analysis-message');
        const analysisResultsDiv = document.getElementById('analysis-results');
        const resultsTableBody = document.getElementById('results-table-body');
        const noVulnerabilitiesMessage = document.getElementById('no-vulnerabilities-message');
        const autoPatchSection = document.getElementById('auto-patch-section');
        const patchButton = document.getElementById('patch-button');
        const patchedCodeDisplay = document.getElementById('patched-code-display');
        const patchedCodePre = document.getElementById('patched-code-pre');
        const patchMessage = document.getElementById('patch-message');
        const patchLogDetails = document.getElementById('patch-log-details');
        const patchLogPre = document.getElementById('patch-log-pre');
        const transientNotification = document.getElementById('transient-notification');

        // Global state variables for current file/code being processed
        let currentProcessedFile = null; // Stores File object for single .java or null
        let currentProcessedCodeString = null; // Stores string for pasted code
        let currentProcessedZipFile = null; // Stores File object for ZIP

        // Caches for analysis and patch results to prevent redundant API calls
        const analysisCache = new Map(); // Key: content hash, Value: { analysis_items, complete_sanitized_code_overall } or { zip_file_results }
        const patchCache = new Map(); // Key: content hash, Value: { patched_code, patch_logs }

        // Cache for ZIP file contents (stores Blob objects) and the ZIP file's hash
        const zipFileCache = new Map();
        let zipFileContentHash = null;

        // --- Utility Functions ---

        // Calculates a SHA-256 hash of a buffer and returns a hex string.
        async function digestToHex(buffer) {
            const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Calculates SHA-256 hash of a File object's content
        async function calculateFileHash(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async function(event) {
                    try {
                        const arrayBuffer = event.target.result;
                        const hashHex = await digestToHex(arrayBuffer);
                        resolve(hashHex);
                    } catch (e) {
                        reject(e);
                    }
                };
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        // Calculates SHA-256 hash of a string
        async function calculateStringHash(str) {
            const encoder = new TextEncoder();
            const data = encoder.encode(str);
            return await digestToHex(data);
        }

        // Shows a persistent message (e.g., for errors or success)
        function showPersistentMessage(element, type, message) {
            const colors = {
                info: 'border-sky-300 bg-sky-50 text-sky-800',
                success: 'border-green-300 bg-green-50 text-green-800',
                warning: 'border-amber-300 bg-amber-50 text-amber-800',
                error: 'border-red-300 bg-red-50 text-red-800',
            };
            element.className = `message-box ${colors[type]}`; // Reset and apply new classes
            element.innerHTML = message; // Use innerHTML to allow for bold/emojis
            setTimeout(() => element.classList.add('show'), 10); // Animate in
        }

        // Hides a persistent message
        function hidePersistentMessage(element) {
            element.classList.remove('show');
        }
        
        // Helper to escape HTML to prevent XSS
        function escapeHTML(str) {
            const p = document.createElement('p');
            p.textContent = str;
            return p.innerHTML;
        }
        
        // Shows a short-lived notification (e.g., "Copied!")
        function showTransientNotification(message, type = 'success') {
             const colors = {
                success: 'bg-green-500',
                error: 'bg-red-500',
            };
            transientNotification.textContent = message;
            transientNotification.className = ``; // Clear classes
            transientNotification.classList.add(colors[type]);
            
            transientNotification.classList.add('show');

            setTimeout(() => {
                transientNotification.classList.remove('show');
            }, 2500);
        }

        // Toggles visibility of a loading spinner
        function toggleLoadingSpinner(spinnerElement, show) {
            if (show) spinnerElement.classList.add('show');
            else spinnerElement.classList.remove('show');
        }
        
        // Toggles visibility of a major UI section with an animation
        function toggleSectionVisibility(sectionElement, show) {
             if (show) {
                sectionElement.classList.remove('hidden-visually'); // Remove hidden first
                setTimeout(() => sectionElement.classList.add('show'), 10); // Then add show for animation
            } else {
                sectionElement.classList.remove('show');
                // Use a short delay before hiding to allow CSS transition to complete
                setTimeout(() => sectionElement.classList.add('hidden-visually'), 500);
            }
        }
        
        // Resets the UI to its initial state before a scan
        function resetUniversalUI() {
            hidePersistentMessage(analysisMessage);
            hidePersistentMessage(patchMessage);
            toggleSectionVisibility(analysisResultsDiv, false);
            toggleSectionVisibility(autoPatchSection, false);
            toggleSectionVisibility(patchedCodeDisplay, false);
            toggleSectionVisibility(patchLogDetails, false);
            noVulnerabilitiesMessage.classList.add('hidden'); // This one has a specific class toggle
            resultsTableBody.innerHTML = '';
            patchedCodePre.innerHTML = '';
            patchLogPre.textContent = '';
            patchButton.disabled = true; // Always disable patch button initially
        }

        // Severity to Emoji mapping
        function getSeverityBadge(severity) {
            const styles = {
                CRITICAL: 'bg-red-100 text-red-800',
                HIGH: 'bg-orange-100 text-orange-800',
                MEDIUM: 'bg-amber-100 text-amber-800',
                LOW: 'bg-slate-100 text-slate-800',
                INFO: 'bg-blue-100 text-blue-800', // Added INFO style
                UNKNOWN: 'bg-gray-100 text-gray-800',
                ERROR: 'bg-red-200 text-red-900',
            };
            const emoji = {
                CRITICAL: 'üî¥', HIGH: 'üî•', MEDIUM: 'üü°', LOW: '‚ö™Ô∏è', INFO: '‚ÑπÔ∏è', UNKNOWN: '‚ùì', ERROR: '‚ùó'
            }
            return `<span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${styles[severity] || styles.UNKNOWN}">
                        ${emoji[severity] || emoji.UNKNOWN} ${severity}
                    </span>`;
        }

        // Helper to format code with line numbers and escape HTML
        function formatCodeWithLineNumbers(codeString) {
            if (!codeString) return '';
            const lines = codeString.split('\n');
            let html = '<div class="line-numbers-container">';
            const escapeDiv = document.createElement('div');
            lines.forEach(line => {
                escapeDiv.textContent = line; // Sanitize HTML
                html += `<span class="line">${escapeDiv.innerHTML || '&nbsp;'}</span>`;
            });
            html += '</div>';
            return html;
        }

        // --- Core API Call Function ---
        async function callBackendApi(endpoint, fileName, fileContent, timeout = 30000) {
            const api_url = `/{endpoint}`;
            const formData = new FormData();
            // fileContent can be Blob (for File) or string (for pasted code)
            const blob = fileContent instanceof File ? fileContent : new Blob([fileContent], { type: 'text/plain' });
            formData.append('file', blob, fileName);

            try {
                const response = await fetch(api_url, {
                    method: 'POST',
                    body: formData,
                    signal: AbortSignal.timeout(timeout) 
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Server error: ${response.status} - ${errorText}`);
                }

                return { ok: true, data: await response.json() };
            } catch (error) {
                let errorMessage = `API call to '${endpoint}' failed: ${error.message}.`;
                if (error.name === 'AbortError') {
                    errorMessage = `API call to '${endpoint}' timed out. The server took too long to respond.`;
                } else if (error.message.includes('Failed to fetch')) {
                    errorMessage = `Connection failed. Is the backend server running? Check the browser's network tab for details.`;
                }
                return { ok: false, error: errorMessage };
            }
        }

        // --- Display Analysis Results ---
        function displayAnalysisResults(analysisItems, targetTableBody, showPatchButton = true) {
            targetTableBody.innerHTML = ''; // Clear previous results
            const tableContainer = targetTableBody.closest('.table-container'); // Get the parent table container
            
            // Check for specific "No vulnerabilities found" or error messages
            if (analysisItems.length === 1 && analysisItems[0].severity === "INFO" && 
                analysisItems[0].issue === "No vulnerabilities found by analyzer.") {
                noVulnerabilitiesMessage.classList.remove('hidden');
                noVulnerabilitiesMessage.classList.add('show'); // Make it visible
                toggleSectionVisibility(analysisResultsDiv, true);
                toggleSectionVisibility(autoPatchSection, false); // No need for patch button
                patchButton.disabled = true;
                if (tableContainer) tableContainer.classList.add('hidden'); // Hide table container
                return false; // No vulnerabilities found
            } else if (analysisItems.length === 1 && analysisItems[0].severity === "ERROR") {
                showPersistentMessage(analysisMessage, 'error', `**‚ùó Analysis Error**: ${analysisItems[0].issue}`);
                toggleSectionVisibility(analysisResultsDiv, false); // Hide analysis results div completely for errors
                if (tableContainer) tableContainer.classList.add('hidden'); // Hide table container
                toggleSectionVisibility(autoPatchSection, false);
                patchButton.disabled = true;
                return false; // Error occurred
            }

            // Filter out specific info/error messages for display in table
            const validIssues = analysisItems.filter(item => 
                item.severity !== "ERROR" && 
                !(item.severity === "INFO" && item.issue === "No vulnerabilities found by analyzer.")
            );

            if (validIssues.length > 0) {
                if (tableContainer) tableContainer.classList.remove('hidden'); // Ensure table is visible
                validIssues.forEach((item, index) => {
                    const row = targetTableBody.insertRow();
                    row.className = 'transition-opacity duration-500 opacity-0';
                    const fullIssueDetails = escapeHTML(item.issue || '-');
                    const suggestionDetails = escapeHTML(item.suggestion || 'N/A');

                    row.innerHTML = `
                        <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-slate-900">${item.line || '-'}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm">${getSeverityBadge(item.severity)}</td>
                        <td class="px-6 py-4 text-sm text-slate-600 max-w-xs break-words">${fullIssueDetails}</td>
                        <td class="px-6 py-4 text-sm text-slate-600 max-w-xs break-words">${suggestionDetails}</td>
                        <td class="px-6 py-4 font-mono text-xs max-w-sm">
                            ${item.sanitized_code ? `<pre class="bg-slate-100 p-2 rounded-md border border-slate-200 text-slate-700 line-numbers-container">${formatCodeWithLineNumbers(item.sanitized_code)}</pre>` : '-'}
                        </td>
                    `;
                    setTimeout(() => row.style.opacity = 1, 100 + (index * 50));
                });
                toggleSectionVisibility(analysisResultsDiv, true);
                if (showPatchButton) {
                    toggleSectionVisibility(autoPatchSection, true);
                    patchButton.disabled = false;
                } else {
                    toggleSectionVisibility(autoPatchSection, false); // No universal patch button for ZIP individual files
                    patchButton.disabled = true;
                }
                return true; // Vulnerabilities found
            } else {
                // This else is for when validIssues.length is 0, meaning no actual vulns after filtering
                noVulnerabilitiesMessage.classList.remove('hidden');
                noVulnerabilitiesMessage.classList.add('show'); // Make it visible
                toggleSectionVisibility(analysisResultsDiv, true);
                toggleSectionVisibility(autoPatchSection, false); // No need for patch button
                patchButton.disabled = true;
                if (tableContainer) tableContainer.classList.add('hidden'); // Hide table container
                return false; // No vulnerabilities found
            }
        }

        // --- Tab Switching Logic ---
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const targetTab = button.dataset.tab;

                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                tabContents.forEach(content => {
                    if (content.id === `${targetTab}-tab-content`) {
                        content.classList.add('active');
                    } else {
                        content.classList.remove('active');
                    }
                });
                resetUniversalUI(); // Reset UI when switching tabs
                // Clear selected files/code for consistency
                currentProcessedFile = null;
                singleFileNameSpan.textContent = 'No file chosen';
                singleFileNameSpan.classList.remove('font-semibold', 'text-sky-700');
                scanSingleFileButton.disabled = true;

                currentProcessedCodeString = null;
                pastedCodeTextarea.value = '';
                scanPastedCodeButton.disabled = false; // Always enabled for text area

                currentProcessedZipFile = null;
                zipFileNameSpan.textContent = 'No ZIP file chosen';
                zipFileNameSpan.classList.remove('font-semibold', 'text-sky-700');
                processZipButton.disabled = true;
                zipResultsContainer.innerHTML = ''; // Clear ZIP specific results

                // Optionally, clear caches if switching tabs should completely reset the app's memory
                // For this app, it's probably better to keep caches separate per type for a smoother UX if user goes back and forth
                // analysisCache.clear();
                // patchCache.clear();
            });
        });

        // --- Logic for Upload .java File Tab ---
        function handleSingleFileSelect(file) {
            if (file && file.name.endsWith('.java')) {
                currentProcessedFile = file;
                singleFileNameSpan.textContent = currentProcessedFile.name;
                singleFileNameSpan.classList.add('font-semibold', 'text-sky-700');
                scanSingleFileButton.disabled = false;
                resetUniversalUI();
            } else {
                showTransientNotification('Please select a .java file.', 'error');
                currentProcessedFile = null;
                singleFileNameSpan.textContent = 'No file chosen';
                singleFileNameSpan.classList.remove('font-semibold', 'text-sky-700');
                scanSingleFileButton.disabled = true;
                resetUniversalUI();
            }
        }
        
        singleFileInput.addEventListener('change', (event) => handleSingleFileSelect(event.target.files[0]));
        
        // Drag and Drop listeners for single file
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            singleFileDropArea.addEventListener(eventName, e => { e.preventDefault(); e.stopPropagation(); });
        });
        ['dragenter', 'dragover'].forEach(eventName => {
            singleFileDropArea.addEventListener(eventName, () => { singleFileDropArea.classList.add('bg-sky-50', 'border-sky-300'); });
        });
        ['dragleave', 'drop'].forEach(eventName => {
            singleFileDropArea.addEventListener(eventName, () => { singleFileDropArea.classList.remove('bg-sky-50', 'border-sky-300'); });
        });
        singleFileDropArea.addEventListener('drop', (event) => { handleSingleFileSelect(event.dataTransfer.files[0]); });
        
        scanSingleFileButton.addEventListener('click', async () => {
            if (!currentProcessedFile) {
                showPersistentMessage(analysisMessage, 'error', 'Please select a Java file to scan.');
                return;
            }

            resetUniversalUI();
            toggleLoadingSpinner(loadingAnalysis, true);
            scanSingleFileButton.disabled = true;

            const fileHash = await calculateFileHash(currentProcessedFile);
            if (analysisCache.has(fileHash)) {
                const cachedData = analysisCache.get(fileHash);
                const vulnerabilitiesFound = displayAnalysisResults(cachedData.analysis_items, resultsTableBody);

                if (cachedData.complete_sanitized_code_overall) {
                    showPersistentMessage(analysisMessage, 'info', 'Cached analysis loaded. Full auto-patched code available.');
                    patchedCodePre.innerHTML = formatCodeWithLineNumbers(cachedData.complete_sanitized_code_overall);
                    toggleSectionVisibility(patchedCodeDisplay, true);
                    patchButton.disabled = true;
                } else if (patchCache.has(fileHash)) { // Check patch cache if no complete_sanitized_code_overall from analyzer
                    const cachedPatch = patchCache.get(fileHash);
                    patchedCodePre.innerHTML = formatCodeWithLineNumbers(cachedPatch.patched_code);

                    if (Array.isArray(cachedPatch.patch_logs) && cachedPatch.patch_logs.length > 0) {
                        let formattedLogs = '';
                        cachedPatch.patch_logs.forEach(logEntry => {
                            const line = logEntry.line !== undefined ? `Line ${logEntry.line}` : 'N/A Line';
                            const message = logEntry.message || 'No message provided.';
                            formattedLogs += `${line}: ${message}\n`;
                        });
                        patchLogPre.textContent = formattedLogs.trim();
                        toggleSectionVisibility(patchLogDetails, true);
                    } else if (typeof cachedPatch.patch_logs === 'string' && cachedPatch.patch_logs.trim()) {
                        patchLogPre.textContent = cachedPatch.patch_logs.trim();
                        toggleSectionVisibility(patchLogDetails, true);
                    } else {
                        patchLogPre.textContent = 'No specific patch logs were generated.';
                        toggleSectionVisibility(patchLogDetails, true);
                    }
                    showPersistentMessage(analysisMessage, 'info', 'Cached analysis and previously patched code loaded!');
                    // Ensure patchedCodeDisplay is shown and patchButton is disabled
                    toggleSectionVisibility(patchedCodeDisplay, true);
                    patchButton.disabled = true;
                } else if (vulnerabilitiesFound) {
                    showPersistentMessage(analysisMessage, 'info', 'Cached analysis loaded. Review findings and consider auto-patching.');
                } else {
                    showPersistentMessage(analysisMessage, 'info', 'Cached analysis loaded. No vulnerabilities found.');
                }

                toggleLoadingSpinner(loadingAnalysis, false);
                scanSingleFileButton.disabled = false;
                return;
            }

            const analysisResult = await callBackendApi('analyze', currentProcessedFile.name, currentProcessedFile, 30000);

            if (analysisResult.ok) {
                const resultsPayload = analysisResult.data.report || [];
                const tempAnalysisItems = [];
                let completeSanitizedCodeOverall = null;

                resultsPayload.forEach(item => {
                    if ("complete_sanitized_code" in item) {
                        completeSanitizedCodeOverall = item.complete_sanitized_code;
                    } else {
                        tempAnalysisItems.push(item);
                    }
                });

                const analysisItemsToCache = tempAnalysisItems.length > 0 ? tempAnalysisItems : [{"issue": "No vulnerabilities found by analyzer.", "severity": "INFO"}];
                
                // Cache the results
                analysisCache.set(fileHash, {
                    analysis_items: analysisItemsToCache,
                    complete_sanitized_code_overall: completeSanitizedCodeOverall
                });

                const vulnerabilitiesFound = displayAnalysisResults(analysisItemsToCache, resultsTableBody);
                if (completeSanitizedCodeOverall) {
                    showPersistentMessage(analysisMessage, 'success', 'Analysis complete. Full auto-patched code available.');
                    patchedCodePre.innerHTML = formatCodeWithLineNumbers(completeSanitizedCodeOverall);
                    toggleSectionVisibility(patchedCodeDisplay, true);
                    patchButton.disabled = true; // No separate patch button if full code is already returned
                } else if (vulnerabilitiesFound) {
                    showPersistentMessage(analysisMessage, 'success', 'Analysis complete. Review findings and consider auto-patching.');
                } else {
                    showPersistentMessage(analysisMessage, 'success', 'Analysis complete. No vulnerabilities found.');
                }
            } else {
                showPersistentMessage(analysisMessage, 'error', analysisResult.error);
            }
            toggleLoadingSpinner(loadingAnalysis, false);
            scanSingleFileButton.disabled = false;
        });

        // --- Logic for Paste Java Code Tab ---
        scanPastedCodeButton.addEventListener('click', async () => {
            const pastedCode = pastedCodeTextarea.value.trim();
            if (!pastedCode) {
                showPersistentMessage(analysisMessage, 'error', 'Please paste some Java code to scan.');
                return;
            }
            
            resetUniversalUI();
            toggleLoadingSpinner(loadingAnalysis, true);
            scanPastedCodeButton.disabled = true;

            currentProcessedCodeString = pastedCode;
            const codeHash = await calculateStringHash(pastedCode);

            if (analysisCache.has(codeHash)) {
                const cachedData = analysisCache.get(codeHash);
                const vulnerabilitiesFound = displayAnalysisResults(cachedData.analysis_items, resultsTableBody);

                if (cachedData.complete_sanitized_code_overall) {
                    showPersistentMessage(analysisMessage, 'info', 'Cached analysis loaded. Full auto-patched code available.');
                    patchedCodePre.innerHTML = formatCodeWithLineNumbers(cachedData.complete_sanitized_code_overall);
                    toggleSectionVisibility(patchedCodeDisplay, true);
                    patchButton.disabled = true;
                } else if (patchCache.has(codeHash)) { // Check patch cache if no complete_sanitized_code_overall from analyzer
                    const cachedPatch = patchCache.get(codeHash);
                    patchedCodePre.innerHTML = formatCodeWithLineNumbers(cachedPatch.patched_code);

                    if (Array.isArray(cachedPatch.patch_logs) && cachedPatch.patch_logs.length > 0) {
                        let formattedLogs = '';
                        cachedPatch.patch_logs.forEach(logEntry => {
                            const line = logEntry.line !== undefined ? `Line ${logEntry.line}` : 'N/A Line';
                            const message = logEntry.message || 'No message provided.';
                            formattedLogs += `${line}: ${message}\n`;
                        });
                        patchLogPre.textContent = formattedLogs.trim();
                        toggleSectionVisibility(patchLogDetails, true);
                    } else if (typeof cachedPatch.patch_logs === 'string' && cachedPatch.patch_logs.trim()) {
                        patchLogPre.textContent = cachedPatch.patch_logs.trim();
                        toggleSectionVisibility(patchLogDetails, true);
                    } else {
                        patchLogPre.textContent = 'No specific patch logs were generated.';
                        toggleSectionVisibility(patchLogDetails, true);
                    }
                    showPersistentMessage(analysisMessage, 'info', 'Cached analysis and previously patched code loaded!');
                    // Ensure patchedCodeDisplay is shown and patchButton is disabled
                    toggleSectionVisibility(patchedCodeDisplay, true);
                    patchButton.disabled = true;
                } else if (vulnerabilitiesFound) {
                    showPersistentMessage(analysisMessage, 'info', 'Cached analysis loaded. Review findings and consider auto-patching.');
                } else {
                    showPersistentMessage(analysisMessage, 'info', 'Cached analysis loaded. No vulnerabilities found.');
                }

                toggleLoadingSpinner(loadingAnalysis, false);
                scanPastedCodeButton.disabled = false;
                return;
            }

            const analysisResult = await callBackendApi('analyze', 'pasted_code.java', pastedCode, 30000);

            if (analysisResult.ok) {
                const resultsPayload = analysisResult.data.report || [];
                const tempAnalysisItems = [];
                let completeSanitizedCodeOverall = null;

                resultsPayload.forEach(item => {
                    if ("complete_sanitized_code" in item) {
                        completeSanitizedCodeOverall = item.complete_sanitized_code;
                    } else {
                        tempAnalysisItems.push(item);
                    }
                });
                
                const analysisItemsToCache = tempAnalysisItems.length > 0 ? tempAnalysisItems : [{"issue": "No vulnerabilities found by analyzer.", "severity": "INFO"}];

                // Cache the results
                analysisCache.set(codeHash, {
                    analysis_items: analysisItemsToCache,
                    complete_sanitized_code_overall: completeSanitizedCodeOverall
                });

                const vulnerabilitiesFound = displayAnalysisResults(analysisItemsToCache, resultsTableBody);
                if (completeSanitizedCodeOverall) {
                    showPersistentMessage(analysisMessage, 'success', 'Analysis complete. Full auto-patched code available.');
                    patchedCodePre.innerHTML = formatCodeWithLineNumbers(completeSanitizedCodeOverall);
                    toggleSectionVisibility(patchedCodeDisplay, true);
                    patchButton.disabled = true; // No separate patch button if full code is already returned
                } else if (vulnerabilitiesFound) {
                    showPersistentMessage(analysisMessage, 'success', 'Analysis complete. Review findings and consider auto-patching.');
                } else {
                    showPersistentMessage(analysisMessage, 'success', 'Analysis complete. No vulnerabilities found.');
                }
            } else {
                showPersistentMessage(analysisMessage, 'error', analysisResult.error);
            }
            toggleLoadingSpinner(loadingAnalysis, false);
            scanPastedCodeButton.disabled = false;
        });

        // --- Logic for Auto-Patch Button (Universal) ---
        patchButton.addEventListener('click', async () => {
            let fileName;
            let fileContent;
            let currentHash;

            if (currentProcessedFile) {
                fileName = currentProcessedFile.name;
                fileContent = currentProcessedFile;
                currentHash = await calculateFileHash(currentProcessedFile);
            } else if (currentProcessedCodeString) {
                fileName = 'pasted_code.java';
                fileContent = currentProcessedCodeString;
                currentHash = await calculateStringHash(currentProcessedCodeString);
            } else {
                showPersistentMessage(patchMessage, 'error', 'No Java file or code selected for patching.');
                return;
            }

            // Don't reset the entire UI. Just reset the patch-specific parts
            // to keep the analysis results visible for context.
            hidePersistentMessage(patchMessage);
            toggleSectionVisibility(patchedCodeDisplay, false);
            toggleSectionVisibility(patchLogDetails, false);
            patchedCodePre.innerHTML = '';
            patchLogPre.textContent = '';

            toggleLoadingSpinner(loadingPatch, true);
            patchButton.disabled = true; // Disable during patch operation

            const patchResult = await callBackendApi('patch', fileName, fileContent);

            toggleLoadingSpinner(loadingPatch, false);

            if (patchResult.ok) {
                const { patched_code, patch_logs } = patchResult.data;
                patchedCodePre.innerHTML = formatCodeWithLineNumbers(patched_code);
                toggleSectionVisibility(patchedCodeDisplay, true);

                // Patch logs handling
                if (Array.isArray(patch_logs) && patch_logs.length > 0) {
                    let formattedLogs = '';
                    patch_logs.forEach(logEntry => {
                        const line = logEntry.line !== undefined ? `Line ${logEntry.line}` : 'N/A Line';
                        const message = logEntry.message || 'No message provided.';
                        formattedLogs += `${line}: ${message}\n`;
                    });
                    patchLogPre.textContent = formattedLogs.trim();
                    toggleSectionVisibility(patchLogDetails, true);
                } else if (typeof patch_logs === 'string' && patch_logs.trim()) {
                    // Fallback for unexpected string format, just in case
                    patchLogPre.textContent = patch_logs.trim();
                    toggleSectionVisibility(patchLogDetails, true);
                }
                else {
                    patchLogPre.textContent = 'No specific patch logs were generated.';
                    toggleSectionVisibility(patchLogDetails, true);
                }

                // Cache the patch result
                patchCache.set(currentHash, { patched_code, patch_logs });

                showPersistentMessage(patchMessage, 'success', 'Code successfully patched!');
                patchButton.disabled = true; // Keep disabled on success
            } else {
                showPersistentMessage(patchMessage, 'error', patchResult.error);
                patchButton.disabled = false; // Re-enable on failure to allow retry
            }
        });

        // --- Logic for ZIP File Upload Tab ---
        function handleZipFileSelect(file) {
            if (file && file.name.endsWith('.zip')) {
                currentProcessedZipFile = file;
                zipFileNameSpan.textContent = currentProcessedZipFile.name;
                zipFileNameSpan.classList.add('font-semibold', 'text-sky-700');
                processZipButton.disabled = false;
                resetUniversalUI(); // Reset universal UI when a new ZIP is selected
                zipResultsContainer.innerHTML = ''; // Clear previous ZIP results
            } else {
                showTransientNotification('Please select a .zip file.', 'error');
                currentProcessedZipFile = null;
                zipFileNameSpan.textContent = 'No ZIP file chosen';
                zipFileNameSpan.classList.remove('font-semibold', 'text-sky-700');
                processZipButton.disabled = true;
                zipResultsContainer.innerHTML = '';
            }
        }

        zipFileInput.addEventListener('change', (event) => handleZipFileSelect(event.target.files[0]));
        
        // Drag and Drop listeners for ZIP file
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            zipFileDropArea.addEventListener(eventName, e => { e.preventDefault(); e.stopPropagation(); });
        });
        ['dragenter', 'dragover'].forEach(eventName => {
            zipFileDropArea.addEventListener(eventName, () => { zipFileDropArea.classList.add('bg-sky-50', 'border-sky-300'); });
        });
        ['dragleave', 'drop'].forEach(eventName => {
            zipFileDropArea.addEventListener(eventName, () => { zipFileDropArea.classList.remove('bg-sky-50', 'border-sky-300'); });
        });
        zipFileDropArea.addEventListener('drop', (event) => { handleZipFileSelect(event.dataTransfer.files[0]); });

        // Helper to display results for individual files within a ZIP
        async function displayZipFileResults(fileName, analysisItems, patchedCode = null, patchLogs = null) {
            let fileContainer = document.getElementById(`zip-file-container-${fileName.replace(/\./g, '-')}`);
            let isNew = false;
            if (!fileContainer) {
                isNew = true;
                fileContainer = document.createElement('div');
                fileContainer.id = `zip-file-container-${fileName.replace(/\./g, '-')}`;
                fileContainer.className = 'bg-white p-6 rounded-xl shadow-lg mb-8 revealable';
                fileContainer.innerHTML = `
                    <h3 class="text-xl font-bold text-slate-800 mb-4">File: <span class="font-mono">${fileName}</span></h3>
                    <div id="zip-file-analysis-message-${fileName.replace(/\./g, '-')}" class="message-box mt-4"></div>
                    <div id="zip-file-table-container-${fileName.replace(/\./g, '-')}" class="table-container mt-4 hidden">
                        <table class="min-w-full">
                            <thead>
                                <tr>
                                    <th class="px-6 py-4">Line</th>
                                    <th class="px-6 py-4">Severity</th>
                                    <th class="px-6 py-4">Issue</th>
                                    <th class="px-6 py-4">Suggestion</th>
                                    <th class="px-6 py-4">Code Snippet</th>
                                </tr>
                            </thead>
                            <tbody id="zip-file-results-table-body-${fileName.replace(/\./g, '-')}" class="bg-white divide-y divide-slate-200">
                                </tbody>
                        </table>
                    </div>
                    <div id="zip-file-no-vulnerabilities-message-${fileName.replace(/\./g, '-')}" class="message-box success mt-6 border-green-300 bg-green-50 text-green-800 hidden">
                        ‚úÖ No SSL/HTTPS vulnerabilities found in ${fileName}.
                    </div>
                    <div class="mt-6 text-center">
                        <button id="zip-patch-button-${fileName.replace(/\./g, '-')}" class="button bg-emerald-600 text-white hover:bg-emerald-700 disabled:opacity-50 disabled:cursor-not-allowed">
                            Patch This File
                        </button>
                    </div>
                    <div id="zip-loading-patch-${fileName.replace(/\./g, '-')}" class="loading-spinner"></div>
                    <div id="zip-patch-message-${fileName.replace(/\./g, '-')}" class="message-box mt-4"></div>
                    <div id="zip-patched-code-display-${fileName.replace(/\./g, '-')}" class="revealable mt-8 text-left hidden-visually">
                        <div class="flex justify-between items-center mb-4">
                            <h4 class="text-xl font-bold text-slate-600">Patched Code for ${fileName}:</h4>
                            <button class="button text-sm py-2 px-4 bg-slate-700 text-white hover:bg-slate-800" onclick="copyToClipboard('zip-patched-code-pre-${fileName.replace(/\./g, '-')}')">Copy Code</button>
                        </div>
                        <pre id="zip-patched-code-pre-${fileName.replace(/\./g, '-')}" class="mt-2 line-numbers-container"></pre>
                        
                        <div id="zip-patch-log-details-${fileName.replace(/\./g, '-')}" class="revealable mt-8 hidden-visually">
                            <h5 class="font-semibold text-lg mb-3 text-sky-800">Patch Log Details for ${fileName}:</h5>
                            <pre id="zip-patch-log-pre-${fileName.replace(/\./g, '-')}" class="bg-sky-50 text-sky-900 border border-sky-200"></pre>
                            <div class="text-sm mt-3 text-sky-700">The patch log shows all changes (line numbers and descriptions) applied by the Auto-Patcher for this file.</div>
                        </div>
                    </div>
                `;
                zipResultsContainer.appendChild(fileContainer);
                setTimeout(() => fileContainer.classList.add('show'), 50); // Animate in
            }

            const fileAnalysisMessage = document.getElementById(`zip-file-analysis-message-${fileName.replace(/\./g, '-')}`);
            const fileResultsTableBody = document.getElementById(`zip-file-results-table-body-${fileName.replace(/\./g, '-')}`);
            const fileNoVulnerabilitiesMessage = document.getElementById(`zip-file-no-vulnerabilities-message-${fileName.replace(/\./g, '-')}`);
            const zipFileTableContainer = document.getElementById(`zip-file-table-container-${fileName.replace(/\./g, '-')}`);
            const zipPatchButton = document.getElementById(`zip-patch-button-${fileName.replace(/\./g, '-')}`);
            const zipPatchedCodeDisplay = document.getElementById(`zip-patched-code-display-${fileName.replace(/\./g, '-')}`);
            const zipPatchedCodePre = document.getElementById(`zip-patched-code-pre-${fileName.replace(/\./g, '-')}`);
            const zipPatchLogDetails = document.getElementById(`zip-patch-log-details-${fileName.replace(/\./g, '-')}`);
            const zipPatchLogPre = document.getElementById(`zip-patch-log-pre-${fileName.replace(/\./g, '-')}`);

            fileResultsTableBody.innerHTML = ''; // Clear existing table rows
            fileNoVulnerabilitiesMessage.classList.add('hidden'); // Hide "no vulns" message by default
            hidePersistentMessage(fileAnalysisMessage); // Hide any previous messages

            // Check for specific "No vulnerabilities found" or error messages
            if (analysisItems.length === 1 && analysisItems[0].severity === "INFO" && 
                analysisItems[0].issue === "No vulnerabilities found by analyzer.") {
                fileNoVulnerabilitiesMessage.classList.remove('hidden');
                fileNoVulnerabilitiesMessage.classList.add('show');
                zipPatchButton.disabled = true;
                zipFileTableContainer.classList.add('hidden'); // Hide table
            } else if (analysisItems.length === 1 && analysisItems[0].severity === "ERROR") {
                showPersistentMessage(fileAnalysisMessage, 'error', `**‚ùó Analysis Error for ${fileName}**: ${analysisItems[0].issue}`);
                zipPatchButton.disabled = true;
                zipFileTableContainer.classList.add('hidden'); // Hide table
            } else {
                // Filter out specific info/error messages for display in table
                const validIssues = analysisItems.filter(item => 
                    item.severity !== "ERROR" && 
                    !(item.severity === "INFO" && item.issue === "No vulnerabilities found by analyzer.")
                );

                if (validIssues.length > 0) {
                    zipFileTableContainer.classList.remove('hidden'); // Show table
                    validIssues.forEach((item, index) => {
                        const row = fileResultsTableBody.insertRow();
                        row.className = 'transition-opacity duration-500 opacity-0';
                        const fullIssueDetails = escapeHTML(item.issue || '-');
                        const suggestionDetails = escapeHTML(item.suggestion || 'N/A');

                        row.innerHTML = `
                            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-slate-900">${item.line || '-'}</td>
                            <td class="px-6 py-4 whitespace-nowrap text-sm">${getSeverityBadge(item.severity)}</td>
                            <td class="px-6 py-4 text-sm text-slate-600 max-w-xs break-words">${fullIssueDetails}</td>
                            <td class="px-6 py-4 text-sm text-slate-600 max-w-xs break-words">${suggestionDetails}</td>
                            <td class="px-6 py-4 font-mono text-xs max-w-sm">
                                ${item.sanitized_code ? `<pre class="bg-slate-100 p-2 rounded-md border border-slate-200 text-slate-700 line-numbers-container">${formatCodeWithLineNumbers(item.sanitized_code)}</pre>` : '-'}
                            </td>
                        `;
                        setTimeout(() => row.style.opacity = 1, 100 + (index * 50));
                    });
                    zipPatchButton.disabled = false; // Enable patch button if vulnerabilities found
                } else {
                    fileNoVulnerabilitiesMessage.classList.remove('hidden');
                    fileNoVulnerabilitiesMessage.classList.add('show');
                    zipPatchButton.disabled = true;
                    zipFileTableContainer.classList.add('hidden'); // Hide table
                }
            }

            // Display patched code if available
            if (patchedCode) {
                zipPatchedCodePre.innerHTML = formatCodeWithLineNumbers(patchedCode);
                toggleSectionVisibility(zipPatchedCodeDisplay, true);
                zipPatchButton.disabled = true; // Disable if already patched and shown
            }

            // Display patch logs if available
            if (patchLogs) {
                if (Array.isArray(patchLogs) && patchLogs.length > 0) {
                    let formattedLogs = '';
                    patchLogs.forEach(logEntry => {
                        const line = logEntry.line !== undefined ? `Line ${logEntry.line}` : 'N/A Line';
                        const message = logEntry.message || 'No message provided.';
                        formattedLogs += `${line}: ${message}\n`;
                    });
                    zipPatchLogPre.textContent = formattedLogs.trim();
                    toggleSectionVisibility(zipPatchLogDetails, true);
                } else if (typeof patchLogs === 'string' && patchLogs.trim()) {
                    zipPatchLogPre.textContent = patchLogs.trim();
                    toggleSectionVisibility(zipPatchLogDetails, true);
                }
                else {
                    zipPatchLogPre.textContent = 'No specific patch logs were generated.';
                    toggleSectionVisibility(zipPatchLogDetails, true);
                }
            }

            // Add event listener for the individual patch button for this file, ONLY ONCE on creation.
            if (isNew) {
                zipPatchButton.addEventListener('click', async () => {
                    const fileEntry = zipFileCache.get(fileName);
                    if (!fileEntry) {
                        showPersistentMessage(document.getElementById(`zip-patch-message-${fileName.replace(/\./g, '-')}`), 'error', `File ${fileName} not found in cache for patching.`);
                        return;
                    }

                    const fileCode = await fileEntry.text();

                    const zipLoadingPatch = document.getElementById(`zip-loading-patch-${fileName.replace(/\./g, '-')}`);
                    const zipPatchMessage = document.getElementById(`zip-patch-message-${fileName.replace(/\./g, '-')}`);

                    toggleLoadingSpinner(zipLoadingPatch, true);
                    zipPatchButton.disabled = true;
                    hidePersistentMessage(zipPatchMessage);
                    toggleSectionVisibility(zipPatchedCodeDisplay, false);
                    toggleSectionVisibility(zipPatchLogDetails, false);
                    zipPatchedCodePre.innerHTML = '';
                    zipPatchLogPre.textContent = '';

                    const patchResult = await callBackendApi('patch', fileName, fileCode);

                    toggleLoadingSpinner(zipLoadingPatch, false);

                    if (patchResult.ok) {
                        const { patched_code, patch_logs } = patchResult.data;
                        // Update cache for this specific file within the zip analysis cache
                        const currentAnalysisData = analysisCache.get(zipFileContentHash);
                        if (currentAnalysisData && currentAnalysisData.zip_file_results && currentAnalysisData.zip_file_results[fileName]) {
                            currentAnalysisData.zip_file_results[fileName].patched_code = patched_code;
                            currentAnalysisData.zip_file_results[fileName].patch_logs = patch_logs;
                            analysisCache.set(zipFileContentHash, currentAnalysisData); // Update the main cache
                        }
                        
                        // Re-call this function to display the new patch results
                        displayZipFileResults(fileName, analysisItems, patched_code, patch_logs);

                        showPersistentMessage(zipPatchMessage, 'success', `File '${fileName}' successfully patched!`);
                        zipPatchButton.disabled = true; // Keep disabled after successful patch
                    } else {
                        showPersistentMessage(zipPatchMessage, 'error', patchResult.error);
                        zipPatchButton.disabled = false; // Re-enable on error for retry
                    }
                });
            }
        }

        processZipButton.addEventListener('click', async () => {
            if (!currentProcessedZipFile) {
                showPersistentMessage(analysisMessage, 'error', 'Please upload a ZIP file to process.');
                return;
            }

            resetUniversalUI();
            zipResultsContainer.innerHTML = ''; // Clear previous ZIP results
            toggleLoadingSpinner(loadingAnalysis, true);
            processZipButton.disabled = true;

            zipFileContentHash = await calculateFileHash(currentProcessedZipFile);

            // Check analysis cache for the entire ZIP file hash
            if (analysisCache.has(zipFileContentHash)) {
                const cachedZipData = analysisCache.get(zipFileContentHash);
                showPersistentMessage(analysisMessage, 'info', 'Cached ZIP analysis loaded!');
                
                for (const fileName in cachedZipData.zip_file_results) {
                    const result = cachedZipData.zip_file_results[fileName];
                    displayZipFileResults(fileName, result.analysis_items, result.patched_code, result.patch_logs);
                }
                toggleLoadingSpinner(loadingAnalysis, false);
                processZipButton.disabled = false;
                return;
            }

            const zip = new JSZip();
            let zipFileBytes;
            try {
                zipFileBytes = await currentProcessedZipFile.arrayBuffer();
                await zip.loadAsync(zipFileBytes);
            } catch (e) {
                showPersistentMessage(analysisMessage, 'error', 'Failed to load ZIP file. It might be corrupted or not a valid ZIP archive.');
                toggleLoadingSpinner(loadingAnalysis, false);
                processZipButton.disabled = false;
                return;
            }

            const javaFiles = [];
            zip.forEach((relativePath, zipEntry) => {
                if (!zipEntry.dir && relativePath.toLowerCase().endsWith('.java')) {
                    javaFiles.push({ name: relativePath, entry: zipEntry });
                }
            });

            if (javaFiles.length === 0) {
                showPersistentMessage(analysisMessage, 'warning', 'No .java files found in the uploaded ZIP archive.');
                toggleLoadingSpinner(loadingAnalysis, false);
                processZipButton.disabled = false;
                return;
            }

            const zipAnalysisResults = {}; // To store analysis results for each file in the ZIP
            zipFileCache.clear(); // Clear the file cache for new ZIP

            for (const fileObj of javaFiles) {
                const fileName = fileObj.name;
                const fileBlob = await fileObj.entry.async("blob");
                zipFileCache.set(fileName, fileBlob); // Store the Blob for later patching

                showPersistentMessage(analysisMessage, 'info', `Analyzing ${fileName}...`);
                const analysisResult = await callBackendApi('analyze', fileName, fileBlob, 60000); // Increased timeout for ZIP files

                let analysisItemsForFile = [];
                let completeSanitizedCodeForFile = null;

                if (analysisResult.ok) {
                    const resultsPayload = analysisResult.data.report || [];
                    const tempAnalysisItems = [];
                    resultsPayload.forEach(item => {
                        if ("complete_sanitized_code" in item) {
                            completeSanitizedCodeForFile = item.complete_sanitized_code;
                        } else {
                            tempAnalysisItems.push(item);
                        }
                    });
                    analysisItemsForFile = tempAnalysisItems.length > 0 ? tempAnalysisItems : [{"issue": "No vulnerabilities found by analyzer.", "severity": "INFO"}];
                } else {
                    analysisItemsForFile = [{
                        "line": null,
                        "issue": `Analysis failed: ${analysisResult.error}`,
                        "suggestion": "Check the file content or backend logs.",
                        "sanitized_code": null,
                        "severity": "ERROR"
                    }];
                }

                zipAnalysisResults[fileName] = {
                    analysis_items: analysisItemsForFile,
                    patched_code: completeSanitizedCodeForFile, // Store initial patched code if returned with analysis
                    patch_logs: null // Patch logs will be populated on individual patch action
                };
                displayZipFileResults(fileName, analysisItemsForFile, completeSanitizedCodeForFile, null);
            }

            // Cache the entire ZIP's analysis results
            analysisCache.set(zipFileContentHash, { zip_file_results: zipAnalysisResults });

            showPersistentMessage(analysisMessage, 'success', 'ZIP analysis complete. Review individual file results above.');
            toggleLoadingSpinner(loadingAnalysis, false);
            processZipButton.disabled = false;
        });


        // --- Universal Clipboard Copy Function ---
        function copyToClipboard(elementId) {
            const preElement = document.getElementById(elementId);
            if (!preElement) return;

            // Use the textContent which includes line breaks correctly
            const textToCopy = preElement.textContent;

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(textToCopy).then(() => {
                    showTransientNotification('Copied to clipboard!');
                }).catch(err => {
                    console.error('Failed to copy text using Clipboard API: ', err);
                    showTransientNotification('Copying failed. Check browser permissions.', 'error');
                });
            } else {
                // Fallback using the deprecated execCommand.
                const textarea = document.createElement('textarea');
                textarea.value = textToCopy;
                textarea.style.position = 'fixed'; // Prevent scrolling to bottom of page
                textarea.style.left = '-9999px';
                document.body.appendChild(textarea);
                textarea.focus();
                textarea.select();
                try {
                    document.execCommand('copy');
                    showTransientNotification('Copied to clipboard!');
                } catch (err) {
                    console.error('Fallback copy failed: ', err);
                    showTransientNotification('Copying failed.', 'error');
                } finally {
                    document.body.removeChild(textarea);
                }
            }
        }

        // Initialize state on load
        document.addEventListener('DOMContentLoaded', () => {
            // Activate the first tab by default
            document.querySelector('.tab-button[data-tab="upload-file"]').click();
            resetUniversalUI(); // Ensure initial state is clean
        });

    </script>
</body>
</html>
